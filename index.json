[
    {
        "uri": "/post/cpp-pointers",
        "title": "C++ Pointers (Göstericiler)",
        "content": "Pointer\nKısaca bir hafıza hücresinin ADRESİNİ tutmak için kullanılan değişkenlerdir. Adrsini tuttuğumuz alanda her türlü değişikliği yapabiliriz yani o adresteki veriyi çekebilir veya değiştirebiliriz.\ngösterici olduğunu bildiren işaret: span style=\"color:green\"*/span\n\nTek bir adres 1 byte lik bir alana sahiptir.\n\nKullanımı:\ntür* isim;\n\nÖrnek:\nint dene = 15;\nint deg = 10;\n\nint* po = &dene;\n\nyukarda dene değişkeni için için hafızada 4 byte lik bir alan bulunur ve dene o alana tahsis edilir artık orayı derleyici int olarak kabul eder.\n\nspan style=\"color:green\"int* po/span dediğimizde derleyici int türünden olduğu için hafızada 4 byte lik bir alan arar ve bulduğunda orayı 4 bytlik adres tutan bir alan kabul eder.\n\nspan style=\"color:green\"&/span işareti bir değişkenin soluna konduğunda o değişkenin tutulduğu adresini bize verir ve bu adresi göstericiler tutabilir.\n\nspan style=\"color:green\"&dene/span dediğimiz o değişkenin adresini verir yani:\n\n// çıktısı '0028F960' gibi bir bellek adresi\ncout << &dene;\n\n& işareti olmadan yapsaydık o adrsteki veriyi bize getirecekti yani:\n// çıktısı: 15\ncout << dene;\n\nyukardakini biz göstericimizle göstermek işteseydik:\n// çıktısı: 15\ncout << *po;\n\ngördüğümüz gibi artık po göstericimiz dene değişkeninin adresini tutuyordu yani dene değişkenine istediğini yapar\n\ngelin birde po göstericimizle dene değişkeninin parametresini değiştirelim:\n*po = 256;\n\ncout << \"dene..: \"  << dene << endl; // 256\n\ncout << \"*po..: \" << *po << endl; //256\n\ngördüğümüz gibi dene değişkenin parametresini değiştirdik\n\nhafızada nasıl olduğu:\n\nyukarda derleyici Örnek kodumuz için:\n\nDerlenme yukardan aşağıya olur\nilk önce deneye hafıza adrestlerinden küçükten büyüğe doğru bir tarama yapar ve 4 byte lik uygun bulduğu yere dene değişkenini yerleştir.\nsonra po göstericisine gelir po int türünden bir gösterici olduğu için 4 bytelik bir alana yerleştirir\n\nyukardaki bu yerleştirmeler stack(yığın) hafıza alanında gerçekleşir bu hafıza yerleştirme türü derleyicinin kontrolündedir ilerde daha ayrıntılı anlatacağım stack ve heap hafıza alanlarını\n\nşimdi bir örnek yapalım\nbir fonksiyonla main içindeki 2 değişkeninin parametreleri yer değiştirsin.\ninclude iostream\n\nusing namespace std;\n\n//yer değiştirmeyi yapacak fonksiyonumuz\nvoid degistir(int* a, int* b)\n{\n    // geçici bir değişken oluşturduk ve\n    // a göstericisinin tuttuğu adresteki veriye eşitledik\n    int temp = *a;\n    \n    // b göstericisinin tuttuğu adrsteki degeri a göstericisinin degerine eşitledik\n    *a = *b;\n    \n    // tem içindeki değeri b göstericisine eşitledik\n    *b = temp;\n}\n\nint main()\n{\n    int sayi1 = 15;\n    int sayi2 = 34;\n\n    cout << \":..degistir fonksiyonundan once..:\" << endl;\n    cout << \"sayi1..: \" << sayi1 << endl;\n    cout << \"sayi2..: \" << sayi2 << endl;\n    \n    degistir(&sayi1, &sayi2);\n    \n    cout << \"\\n:..degistir fonksiyonundan sonra..:\" << endl;\n    cout << \"sayi1..: \" << sayi1 << endl;\n    cout << \"sayi2..: \" << sayi2 << endl;\n\n    system(\"PAUSE\");\n    return 0;\n}\n\nyukarda sayi1 in degeri 15 sayi2 nin degeri 34'tü degistri fonksiyonundan sonra sayi1'in degeri 34 sayi2'nin degeri 15 oldu.",
        "tags": [
            "C++",
            "Pointers"
        ]
    },
    {
        "uri": "/post/cpp-pointers2",
        "title": "C++ Pointers (Göstericiler) -2-",
        "content": "\nŞimdi de Dizilerde işaretçi kullanımını görelim:\ninclude iostream\n\nusing namespace std;\n\nint main()\n{\n    int dizi[] = { 10, 20, 30, 40, 50 };\n\n    // po işaretçimiz dizi'nin adresini gösteriyor\n    int *po = dizi;\n\n    // po'nun gösterdiği adresteki verileri ekrana yazdırıyoruz\n\n    for (int i = 0; i < 5; i++)\n        cout << po[i] << endl;\n\n    system(\"PAUSE\");\n    return 0;\n}\n\nYukardaki Kodları Sırayla Açılayalım\n\nint dizi[] = { 10, 20, 30, 40, 50 };\nYukarda \"dizi\" adında int türünden bir dizi oluşturuyoruz bu dizinin içindeki elemanlar otomatik olarak aşağıdaki gibi \"dizi\" ye atanıyor\n\ndizi[0] = 10;\ndizi[1] = 20;\ndizi[2] = 30;\ndizi[3] = 40;\ndizi[4] = 50;\nyukardakilerin stack hafızada 20 bytelik bir alan kaplar bu alanı bir 5 katlı bir dolaba benzetelim dolabın en üst katında dizi[0] en alt katında dizi[4] vardır yani:\n\nyukarda görüldüğü gibi derleyici sıralı bir şekilde stack hafızada \"dizi\" yi yerleştirmiş bir önceki konuda demiştim değişkenlerimizi tanımladığımızda o değişkenleri derleyici stack hafızada yerleşimini yapar yani derleyicinin elindedir ne zaman bizim elimizde olur derseniz onu ileri konuda anlatmayı düşünüyorum.\n\nadresler niye 4'er 4'er artmış derseniz int DÖRT byte'lik bir tam sayı değişkenidir bir önceki konuda ne demiştim \"tek bir adres 1 byte'lik alana sahiptir\" bu durumda int'in saklanması için 4 adres alanı işgal edilecek ama o int çağrılırken 4 adresinden ilk adresi ile çağrılacak.\n\nint* po = dizi;\nYukarıda po adında int türünden bir gösterici tanımladık ve bu göstericiye \"dizi\" yi eşitledik yani ne dedik \"po sen git ve dizi'yi kontrolun altına al\" bu durumda noluyor biz \"dizi\" nin her elemanına ulaşabiliyoruz ve onları değiştirebiliyoruz koddan ayrı bir örnek verelim:\nmesela napsın gitsin dizi[3]'ü değiştirsin dizi[3]'te parametre olarak 40 vardı.\n\npo[3] = 54;\ncout << \"dizi[3]..: \" << dizi[3] << endl;\ncout << \"po[3]..: \" << po[3] << endl;\nyukarda gördüğünüz gibi po \"dizi\" yi gösterdiği için po[3]'e parametre atandığında dizi[3]'e atanmış oluyor yani dizi[3] artık 40 değil 54 olmuştur.\n\npo 4 byte'lik bir alanda durur o nun işi sadece göstermektir yani \"dizi\" toplam 20 byte alanda diye po'da 20 bytelik bir alandadır diye düşünmeyelim po anlık iş yapar yani bi nevi garson gibi bi o masya gider bi bu masaya\n\nfor(int i = 0; i < 5; i++)\n        cout << po[i] << endl;\nyukarıda for için i'yi 0'a eşitlemişiz; koşul olarak i küçük olduğu sürece 5'ten; i'yi 1 arttır\nsonra po[i]'leri ekrana yazdır demişiz yani po neyi gösteriyordu dizi'yi bu durumda ne olması lazım:\n\n10\n20\n30\n40\n50\n\naşağıdaki kodlarda değişime uğramadan gidiyor gibi düşünün\n\npo++;\nböyle bi şey dediğimizde po nun gösterdiği ADRES 4 artar(neden 4 çünkü po int türünden) artık po dizi[1] gösterir yani gelip po[0]'ı ekranda göstermek istediğimizde ekrana dizi[1]'deki parametre çıkar\ndize[0]'a po--; kulanmadığımız sürece erişme şansımız yoktur.\n\n(*po)++;\nböyle bi şey dediğimizde po nun gösterdiği adresteki VERİYİ 1 arttırır yani dizi[0]'daki değer 1 artar.\n\nbir örnekle bu yazıyı bitirelim:\n\nspan style=\"color:green\"main içindeki iki dizi'yi yer değiştirsin yani dizi1'dekiler dizi2'ye dizi2'dekiler dizi'e geçsin:/span\ninclude iostream\n\nusing namespace std;\n\nvoid Hallet(int* d1, int* d2)\n{\n    int temp[5];\n\n    for(int i = 0;i < 5;i++)\n        temp[i] = d1[i];\n\n    for(int i = 0;i < 5;i++)\n        d1[i] = d2[i];\n\n    for(int i = 0;i < 5;i++)\n        d2[i] = temp[i];\n}\n\nint main()\n{\n    int dizi1[] = {10, 20, 30, 40, 50};\n    int dizi2[] = {100, 200, 300, 400, 500};\n\n    cout << \"Hallet() Fonksiyonundan Once dizi1[]..: \" << endl;\n    for(int i = 0;i < 5;i++)\n        cout << dizi1[i] << endl;\n\n    cout << \"\\nHallet() Fonksiyonundan Once dizi2[]..: \" << endl;\n    for(int i = 0;i < 5;i++)\n        cout << dizi2[i] << endl;\n\n    Hallet(dizi1, dizi2);\n    cout << endl;\n\n    cout << \"\\nHallet() Fonksiyonundan Sonra dizi1[]..: \" << endl;\n    for(int i = 0;i < 5;i++)\n        cout << dizi1[i] << endl;\n\n    cout << \"\\nHallet() Fonksiyonundan Sonra dizi2[]..: \" << endl;\n    for(int i = 0;i < 5;i++)\n        cout << dizi2[i] << endl;\n\n    system(\"PAUSE\");\n    return 0;\n}\n",
        "tags": [
            "C++",
            "Pointers"
        ]
    }
]